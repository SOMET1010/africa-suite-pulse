import { supabase } from "@/integrations/supabase/client";

export interface CustomerAccount {
  id: string;
  org_id: string;
  customer_code: string;
  name: string;
  address_line1?: string;
  address_line2?: string;
  postal_code?: string;
  city?: string;
  phone?: string;
  email?: string;
  account_status: 'active' | 'blocked' | 'suspended';
  credit_limit_type: 'unlimited' | 'limited' | 'blocked';
  credit_limit: number;
  current_balance: number;
  loyalty_card_number?: string;
  notes?: string;
  created_at: string;
  updated_at: string;
}

export interface CustomerInvoice {
  id: string;
  org_id: string;
  customer_account_id: string;
  invoice_number: string;
  invoice_date: string;
  due_date?: string;
  total_amount: number;
  paid_amount: number;
  remaining_amount: number;
  status: 'open' | 'partial' | 'paid' | 'cancelled';
  order_data: any;
  table_number?: string;
  server_id?: string;
  session_id?: string;
  created_at: string;
  updated_at: string;
}

export interface CustomerPayment {
  id: string;
  org_id: string;
  customer_account_id: string;
  invoice_id?: string;
  payment_reference: string;
  payment_date: string;
  amount: number;
  payment_method: string;
  notes?: string;
  is_partial: boolean;
  created_at: string;
}

export const posCustomersApi = {
  // Customer Accounts
  async getCustomerAccounts() {
    return supabase
      .from("pos_customer_accounts")
      .select("*")
      .order("name");
  },

  async getCustomerById(id: string) {
    return supabase
      .from("pos_customer_accounts")
      .select("*")
      .eq("id", id)
      .single();
  },

  async createCustomer(customer: Omit<CustomerAccount, 'id' | 'created_at' | 'updated_at' | 'customer_code' | 'current_balance'>) {
    return supabase
      .from("pos_customer_accounts")
      .insert({
        ...customer,
        customer_code: '', // Will be generated by trigger
        current_balance: 0
      })
      .select()
      .single();
  },

  async updateCustomer(id: string, updates: Partial<CustomerAccount>) {
    return supabase
      .from("pos_customer_accounts")
      .update(updates)
      .eq("id", id)
      .select()
      .single();
  },

  async searchCustomers(searchTerm: string) {
    return supabase
      .from("pos_customer_accounts")
      .select("*")
      .or(`name.ilike.%${searchTerm}%,customer_code.ilike.%${searchTerm}%,phone.ilike.%${searchTerm}%`)
      .order("name")
      .limit(20);
  },

  // Customer Invoices
  async getCustomerInvoices(customerId: string) {
    return supabase
      .from("pos_customer_invoices")
      .select("*")
      .eq("customer_account_id", customerId)
      .order("invoice_date", { ascending: false });
  },

  async createCustomerInvoice(invoice: Omit<CustomerInvoice, 'id' | 'created_at' | 'updated_at' | 'invoice_number'>) {
    const { data, error } = await supabase
      .from("pos_customer_invoices")
      .insert({
        ...invoice,
        invoice_number: '', // Will be generated by trigger
        remaining_amount: invoice.total_amount - invoice.paid_amount
      })
      .select()
      .single();

    return { data, error };
  },

  async updateInvoicePayment(invoiceId: string, paidAmount: number) {
    const { data: invoice } = await supabase
      .from("pos_customer_invoices")
      .select("total_amount, paid_amount")
      .eq("id", invoiceId)
      .single();

    if (!invoice) throw new Error("Invoice not found");

    const newPaidAmount = invoice.paid_amount + paidAmount;
    const remainingAmount = invoice.total_amount - newPaidAmount;
    const status = remainingAmount <= 0 ? 'paid' : remainingAmount < invoice.total_amount ? 'partial' : 'open';

    return supabase
      .from("pos_customer_invoices")
      .update({
        paid_amount: newPaidAmount,
        remaining_amount: remainingAmount,
        status
      })
      .eq("id", invoiceId)
      .select()
      .single();
  },

  // Customer Payments
  async getCustomerPayments(customerId: string) {
    return supabase
      .from("pos_customer_payments")
      .select(`
        *,
        pos_customer_invoices(invoice_number)
      `)
      .eq("customer_account_id", customerId)
      .order("payment_date", { ascending: false });
  },

  async createCustomerPayment(payment: Omit<CustomerPayment, 'id' | 'created_at' | 'payment_reference'>) {
    const { data, error } = await supabase
      .from("pos_customer_payments")
      .insert({
        ...payment,
        payment_reference: `PAY-${Date.now()}`
      })
      .select()
      .single();

    // Update invoice if specified
    if (!error && data && payment.invoice_id) {
      await this.updateInvoicePayment(payment.invoice_id, payment.amount);
    }

    return { data, error };
  },

  // Monthly compression
  async compressMonthlyStatements(month: number, year: number) {
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0);

    const { data: customers } = await this.getCustomerAccounts();
    
    if (!customers) return { data: null, error: new Error("No customers found") };

    const compressionResults = [];

    for (const customer of customers) {
      // Get invoices and payments for the period
      const { data: invoices } = await supabase
        .from("pos_customer_invoices")
        .select("*")
        .eq("customer_account_id", customer.id)
        .gte("invoice_date", startDate.toISOString().split('T')[0])
        .lte("invoice_date", endDate.toISOString().split('T')[0]);

      const { data: payments } = await supabase
        .from("pos_customer_payments")
        .select("*")
        .eq("customer_account_id", customer.id)
        .gte("payment_date", startDate.toISOString().split('T')[0])
        .lte("payment_date", endDate.toISOString().split('T')[0]);

      const totalInvoices = invoices?.reduce((sum, inv) => sum + inv.total_amount, 0) || 0;
      const totalPayments = payments?.reduce((sum, pay) => sum + pay.amount, 0) || 0;

      // Create statement
      const { data: statement, error } = await supabase
        .from("pos_customer_statements")
        .insert({
          org_id: customer.org_id,
          customer_account_id: customer.id,
          statement_date: endDate.toISOString().split('T')[0],
          period_start: startDate.toISOString().split('T')[0],
          period_end: endDate.toISOString().split('T')[0],
          opening_balance: customer.current_balance - totalInvoices + totalPayments,
          closing_balance: customer.current_balance,
          total_invoices: totalInvoices,
          total_payments: totalPayments,
          statement_data: {
            invoices: invoices?.length || 0,
            payments: payments?.length || 0
          }
        })
        .select()
        .single();

      compressionResults.push({ customer: customer.name, statement, error });
    }

    return { data: compressionResults, error: null };
  }
};